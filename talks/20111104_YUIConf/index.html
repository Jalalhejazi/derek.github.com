<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>Why YUI | JSConf 2011</title>

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=1024, user-scalable=no">

    <link rel="stylesheet" href="theme/reset.css">
    <link rel="stylesheet" href="build/upstage-deck-core-min.css">
    <link rel="stylesheet" href="theme/transition.css">
    <link rel="stylesheet" href="theme/yuiconf2011.css">
    
    <style>
    .slide h1{
        font-size:2.3em;
    }
    
    .templateB{
        position: relative;
    }
    
    .templateB h3{
        text-align: center;
        font-size: 3.0em;
        top: 20%;
    }
        
    .templateB .slide p {
        font-size: 1.8em;
        margin-left: 5%;
    }
    
    .asd {
        display:none;
    }
    
    .slide a {
        text-decoration:underline;
    }
    
    .slide.deck-previous>.hide-previous {
        display:none;
    }
    </style>
</head>

<body>

<div id="bd" class="deck-container">

    <div class="slide title">
        <h1>Why YUI?</h1>
        <p>Derek Gathright, Yahoo! Inc.</p>
    </div>
    


    <div class="slide">
        <h2>Who is this guy?</h2>
        
        <!-- 
            Hi, I'm Derek Gathright.
            I'm a senior software engineer here at Yahoo where I work on YUI full-time.
            Prior to joining the YUI team, I worked on other projects at Yahoo within Media and Entertainment as a front-end engineer.
            I'm a huge advocate of open-source and I love JavaScript
            You can follow me both on Twitter & Github as @derek
            
        -->
        
        <img style="float:right;" src="http://s89997654.onlinehome.us/screencaps/5238437157_8700c2906d_b.jpg_%281024%C3%97683%29-20111031-192729.jpg" height="350">
        <ul>
            <li>Derek Gathright</li>
            <li>Software engineer, Yahoo!
                <ul>
                    <li>YUI team</li>
                    <li>Yahoo! Media</li>
                    <li>... various startups</li>
                </ul>
            </li>
            <li>&lt;3 open-source</li>
            <li>&lt;3 JavaScript</li>
            <li>Twitter &amp; Github as @derek</li>
        </ul>
    </div>


    <!-- -------- -->


    <div class="slide templateB">
        <h1>What is this talk about?</h1>
        <!--
            So what is this talk about?  That's a good question.  It's a bit more philosophical than most of the talks you'll see here at YUIConf.
            I originally wanted to give a talk on porting an application from another library to YUI, but I felt that was missing 
            the story of why you would want to do that in the first place.  So as I talked to other developers on the YUI team and within the community
            about their favorite parts of the library, and why it is they used YUI, I began to see some patterns emerge.  So this talk is a 
            reflection of those conversations. 
            
            In short, it's a talk about what makes YUI the most uniquely ideal toolkit to build high-scale, maintainable Web applications.
            
            
            
            
            
            Architecture
                1) modules
                2) extensibility
                3) Sandbox
                4) Summary: Debunk "Enterprisey"
                  -simple
                  
              
            Tools
                - Loader
                - Combo service
                - Grids
                
                
            Open
                - Open-source
                    What license?
            
            sandbox
            - http://wtfcontent.com/img/130207816278.jpg
            
              - Not talking about this type of architecture
              http://www.beachwallpapers.in/bulkupload/New_beaches/Beautiful/Sydney%20Opera%20House%20Australia.jpg
              - Talking about this type
              
              http://www.astronautix.com/graphics/i/issstar9.jpg
              http://s89997654.onlinehome.us/screencaps/skitched-20111031-001342.jpg
              http://chamorrobible.org/images/photos/gpw-20061021-NASA-S124-E-010006-black-space-Earth-horizon-white-clouds-blue-water-International-Space-Station-20080611-large.jpg
            
            
            Lincoln Log
            http://www.flickr.com/photos/51306450@N00/1460073230/
            
            Lego catapult
            http://images.mocpages.com/user_thumbnails/webrain2003@speedy.co.il/www.brickshelf.com_gallery_irod_Catapult_00catapult.jpg_SPLASH.jpg
            
            
        
        
        
        
        
            #1 Modular architecture
            #2 Loader
            #3 Combo-loading
            #4 Environment agnostic
            #5 Extensibility
            #6 Accessibility
            #7 Gallery
            #8 Open-source
            #9 It's a JavaScript library
            
            **Maintainability, maximize code resuse
            
            
            Extensiblity
            - Prototypes, building custom objects.
            - JavaScript is ideal for this type of architecture
            - Extend, don't hack
            - Custom events
            - State change patterns to hook into
            - Consistent & formal creation/destruction patterns
            - Graphics, history, storage (YUI2)
            
            
        -->
    </div>


    <!-- --------


    <div class="slide">
        <h2>My history with JS</h2>
        <p class="slide">2005: "I hate JavaScript"</p>
        <p class="slide">2006: "Hmm... This Prototype.js thing ain't so bad"</p>
        <p class="slide">2007: "OMG jQuery &lt;3 &lt;3 &lt;3!1!!"</p>
        <p class="slide">2008: "OMG jQuery &lt;3 &lt;3?"</p>
        <p class="slide">2009: "Hmm... This YUI thing ain't so bad."</p>
        <p class="slide">2010+: "OMG YUI &lt;3 &lt;3 &lt;3!!!"</p>
    </div>
     -->
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Why YUI?</h2>
        <h1>#1: <span class="slide">Architecture</span></h1>
        <!--
            The first 'why' we're going to look at is... architecture.
            When I say "architecture", some people think of this...
        -->
    </div>

        <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            The Sydney Opera House is one of the most recognizable structures on the planet.  
            It's expressionist design is beautiful, elegant, and iconic.
            Some have even called it a masterpiece.  
            
            This isn't the type of architecture I'm talking about though.  
            As beautiful as this opera house is, there's likely not too many lessons we can learn from it about software development.
            
            This type of architecture I'm referring to is more like this.
        -->
        
        <img src="http://www.beachwallpapers.in/bulkupload/New_beaches/Beautiful/Sydney%20Opera%20House%20Australia.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    <div class="slide">
        <h2></h2>
        
        <!--
            Not quite as pretty is it?  Well, there is elegance here, it's just not as apparent in this component diagram.  
            
            Let's view it in it's physical form
        -->
        
        <img src="http://s89997654.onlinehome.us/screencaps/skitched-20111031-001342.jpg" height="500">
        
    </div>
    
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <!--
            The International Space Station wasn't designed with beauty in mind, but it's undeniably there.
            To me, the beauty of the IIS in this picture isn't really because of any visual elements, but of the structure itself.
            
            When we talk about architecture in the sense of software, we're talking about something very similar to the design of something like the IIS.
            Well architected software is composed of reusable and interchangeable components in a way that promotes reliability, maintainability, 
            compatibility, and extensibility.
            
            So let's take a look at some of those "ilities"
        -->
        
        <img src="http://s89997654.onlinehome.us/screencaps/skitched-20111031-203100.jpg" height="500">
        
        <!--
        <img src="http://chamorrobible.org/images/photos/gpw-20061021-NASA-S124-E-010006-black-space-Earth-horizon-white-clouds-blue-water-International-Space-Station-20080611-large.jpg" height="500">
        -->
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h1>Modules</h1>
        
        <!--
            Modules are a concept used across many engineering disciplines.  
            In a space station sense, they refer to the 32 separately constructed components that compose the IIS.
            In a software sense, they similarly refer to bits of focused, interchangeable components that you can use to construct whatever system you are tasked with.
            You'll find native module support in many programming languages.  Ruby, Java, Python.  But unfortunately not in JavaScript.  Why?
            Well, it's pretty obvious.  JavaScript was developed over the course of a few weeks.  I don't think that was a consideration.
            To everyone's surprise though, JS has thrived, and the need for them is there, 
            so it's been left up to developers to design their own module patterns.
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    
    <div class="slide">
        <h2>JS Modules</h2>

        <!-- 
            Here is just one example of a JavaScript module, as proposed on the yuiblog 4 years ago.
            You start with assigning an anonymous function to whatever you want to name your module.  
            Inside this module, you can create whatever private variables you'd like, and you return 
            an object containing things you would like to publicly expose.
            Finally, you execute and return your anonymous function.
            
            There are a number of strengths and weaknesses to this design, and over time, the YUI team finally settled on 
            similar, but slightly different design for YUI3.
        -->
        
        <pre class="slide"><code class="prettyprint">// yuiblog.com/blog/2007/06/12/module-pattern/
myLibrary.fizzbuzz = (function () {

  var somePrivateVar = "Fizz";
  
  return {
    fizzbuzz: myPrivateVar + " Buzz"
  };
  
})();</code></pre>

    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>YUI Modules</h2>

        <!-- 
            This module does the exact same thing the previous example did, the implementation is slightly different though.

            You have the same capabilities for private members, and whatever you'd like to expose to the public is attached to the Y object.

            Modules are a fundamental building block for everything you do in YUI.  Between the Core library and the YUI Gallery, 
            you'll see over 600 modules that you can use inside of your application to do everything from DOM manipulation,
            animation, object-oriented helpers, and many more.

            It is not intended that you use all of them at the same time, but rather to pick and chose only the ones you want.
        -->
        
        <pre><code class="prettyprint">// fizzbuzz.js

YUI.add("fizzbuzz", function(Y){

  // Private variable
  var myPrivateVar = "Fizz";

  // Export as public variable
  Y.fizzbuzz = myPrivateVar + " buzz";

});</code></pre>

    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>JS Modules</h2>
        
        <!-- 
            YUI is one of the few popular JavaScript libraries that uses this modular architecture, 
            but we're seeing greater adoption from other libraries.  We're even starting to see standards emerge, such as AMD and CommonJS.
            
            Dojo is has recently adopted the AMD pattern, and CommonJS Modules/1.1 is very popular within Node.js.  
            
            YUI is really happy with YUI Modules so far, but that's not to say we haven't begun exploring additional support for other formats.  
            If you are curious about the work being done here, check out the YUI forum for discussion about this topic.  
            We're very interested in hearing your feedback.            
            
            The eventual goal is native ECMAScript modules, which are coming, but they're still in the proposal phase.  
            When they've finally arrived, we still won't be able to use them in an environment that needs to support legacy browsers because they 
            won't be compatible with ES3, so I'm not sure how much adoption they'll actually have inside of browsers.  We'll see.
            
            This makes it even more important that we as a JavaScript community come up with a standard that it both backwards, and forwards compatible,
            and one that also runs equally as well server-side and within browsers.
        -->
        
        <p>Emerging standards</p>
        <ul>
            <li>AMD (Asynchronous Module Definition)</li>
            <li>CommonJS Modules/1.1</li>
            <li>CommonJS Modules/2.0 (draft)</li>
            <li>... and more</li>
        </ul>
        <p class="slide">Eventual goal: <a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">ECMAScript Modules</a>.  Still just a proposal, and incompatible with ES3. :(</p>
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <h1>What do you gain from modularity?</h1>
        <!--
            So we've talked about briefly about modular design in JS, but what do you get out of it?  The #1 thing....
        -->
    </div>
    
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Extensibility</h2>
        <!--
            Extensibility
            
            This is the idea that a your code is designed with future growth in mind.  Even, to be able to grow in ways it was never intended.
            When working within a library, it's extremely important that you consider all types of edge-cases, and make it possible for
            developers who are going to be using your code to replace or extend functionality you provide them with their own.
            
            When you think about extensibility with software, a good comparison might be Lightning McQueen.
        -->
        
            <!--
            Extensibility
            - Prototypes, building custom objects.
            - JavaScript is ideal for this type of architecture
            - Extend, don't hack
            - Custom events
            - State change patterns to hook into
            - Consistent & formal creation/destruction patterns
            - Graphics, history, storage (YUI2)
            
            Every YUI component is designed with future growth and compatibility in mind.
                JavaScript is ideal for a fluid environment
                Prototypes
                YUI augment/extend/merge/mix
                Plugins
                Extensions
            -->
        
        <img src="http://dallaschildblog.com/wp-content/uploads/2010/11/308460_4596.jpg" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <!--
        
        This specific toy was designed to be only one thing, look exactly like Lightning McQueen did in the original Cars movie.  
        I'd say they did a pretty good job.  But the problem is what happens in the next sequel when Lightning 
        is getting older and needs rocket boosters to get around the track.  
        Or the sequel after that when he has a midlife crisis and wants to be a convertible.
        
        -->
        
        <img src="http://i1.treklens.com/photos/9392/lmqred.jpg" height="500">
        <!-- source: http://www.treklens.com/gallery/photo149022.htm -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            Something like this might be more appropriate.
            
            [TODO]
        -->
        
        <img src="http://www.pixartalk.com/wp-content/uploads/2011/07/cars2lego.jpg" height="500">
        <!-- source: http://www.pixartalk.com/2011/08/lego-lightning-mcqueen/ -->
        
    </div>
    
    <!-- Time: 10 min -->
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            In application development, one constant is change.  This is especially true on the Web where new ideas, 
            technologies, patterns, techniques, libraries, and standards, are all evolving at an accelerated pace.
            
            Years ago, when I was working on a startup that was using jQuery, a new feature we needed was a rich text editor.
            So I did what most jquery users do, search "jquery rich text editor plugin."  I came across lots of blog posts
            "top 12 jQuery editor plugins", "10 jquery-based rich text editors to blow your mind"  This stuff reads like a Cosmo magazine.
            
            So I click through each one, play around with the demo, figure out which one most meets my spec, plug it in, glue it together, viola. Done.
            
            2 weeks later, "Oh, we need the ability to upload and add pictures within the editor."
            Now my first thought is "Gee, that would have been great to know a few weeks ago."  But that still doesn't change the problem I have.  
            I now have a feature that I need to integrate with an editor that it was never designed to support.
            Sure I could crack open the plugin and start hacking away until I got it working, or just gave up and try another editor.
            
            The point of this is...
        -->
        
        <img src="http://corinnegregory.com/wp-content/uploads/2011/06/change.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!-- 
            Most of our business cards say something similar to "front end engineer", "web engineer".  Well, where do you think the "engineer" part 
            comes from?  Our jobs are not to  throw together a pile of code, hand it over so you can hack in our modifications, 
            and deliver it so some other poor sap that is in charge of maintaining it.  
            You just end up with unmaintainable junk that is thrown away when it no longer fits a spec, and the
            process is destined to repeat itself over again.
            
            Every component within YUI is developed with extensibility in mind.  Some of the teams that use YUI within Yahoo never use the vanilla
            versions of the components we have.  They endlessly modify and extend them to suit their exact needs.
            
            When you talk about things like components, modules, extensibility, one of the things you hear is "Ohhh... that sounds very enterprisey"
            
            So let's talk about this myth
        -->
        
        <h1>Don't hack <br /> <br /> Extend</h1>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide" >
        <h2></h2>
        
        <!-- 
            I go to a lot of meetups, pub nights, and talk with a lot of people about YUI.  This isn't something I hear all the time, but it's something you
            hear enough that it warrants a discussion.
            
            What do you even mean when you say enterprisey?
            
            Are you talking about this? ...
        -->
        
        <h1>Myth: "YUI is too enterprisey"</h1>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Enterprisey?</h2>
        
        <!--
            If so, Awesome!
            I could probably do a whole talk about comparing YUI to the Starship Enterprise.
            But I have a feeling they aren't talking about this.
        -->
        
        <img src="http://images.wikia.com/memoryalpha/en/images/d/df/USS_Enterprise-A_quarter.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Enterprisey?</h2>
        
        <!--
            Instead, it's more something like this.
            
            Modules? Documentation? Scary!
            
            YUI is actually extremely simple if you know how to read a little bit of documentation at yuilibrary.com.
            It's just a suite of tools that naturally evolved to suit the needs of Yahoo, the team, and the community.
            You can use as many, or as few of the tools as you like.  Again, extensible design.
            
            So let's dive into the tools a little more.
        -->
        
        <img src="http://infolific.com/images/fun/metaphor-for-complexity.gif" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Why YUI?</h2>
        <h1>#2: <span class="slide">Tools</span></h1>
        <!-- 
        
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Toolkit</h2>
        
        <!--
            YUI is called a library, but I personally view it more like a toolkit.  That's not saying the "library" term is incorrect.  
            Library, toolkit, and framework are often used interchangeably, so I don't want to get lost in semantics.  
            The reason I say 'toolkit' most accurately describes YUI is because it allows you to pick & choose what it is you want, and nothing more.
        -->
        
        <img src="http://upload.wikimedia.org/wikipedia/commons/f/f4/20060513_toolbox.jpg" height="500">
        
    </div>
    
    <div class="slide">
        <h2>Tools</h2>

        <!--
            If you just want a DOM selector/editor, ok, YUI use "node"
            Canvas/SVG/VML graphics, then use graphics
            Want a calendar widget, use calendar
            YQL client, use YQL

            So these are all YUI core modules, but the world of YUI tools extends well beyond modules, so let's look at some of them.

            The first, is actually a tool to include you modules.
        -->
        
        <pre><code>// DOM
YUI().use('node', function (Y) { ... });

// Canvas/SVG/VML graphics
YUI().use('graphics', function (Y) { ... });

// Calendar widget
YUI().use('calendar', function (Y) { ... });

// YQL client
YUI().use('yql', function (Y) { ... });</code></pre>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>YUI Loader</h2>
        
        <!--
          Addresses blocking by async loading
          Addresses dependencies by automatic dependency resolution
          On-demand modules loading
          Support CSS
        -->
        
        <img src="http://cdn.gajitz.com/wp-content/uploads/2009/10/Power-Loader-Aliens.jpg" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Modules</h2>

        <!-- 
          Blocking because you are cramming all those into the head
          It has a fragile load order, because what if you include your coreLibrary.js last?
          Do you load all your dozens of modules on every page? Load them selectively? How do you handle dependency resolution? Calculation?
          What about CSS dependencies for UI widgets?
        -->
        
        <p>So we organized into modules, great!</p>
        <pre><code class="prettyprint">&lt;head>
  &lt;script src='/js/coreLibrary.js'> &lt;/script>
  &lt;script src='/js/moduleA.js'> &lt;/script>
  &lt;script src='/js/moduleB.js'> &lt;/script>
  &lt;script src='/js/moduleC.js'> &lt;/script>
  &lt;script src='/js/moduleD.js'> &lt;/script>
&lt;/head></code></pre>
    </div>
    
    <!-- -------- -->
    
    <div class="slide templateB">
        <h1>Goal of a module loader? <span class="slide"><br /><br />Optimize &amp; Simplify</span></h1>
        <!-- 
        
        -->
    </div>

    
    <!-- -------- -->
    <div class="slide">
        <h2>Loader</h2>
        
        <!-- 
        
        -->
        
        <p>YUI Modules example (again)</p>
        <pre><code class="prettyprint">// fizzbuzz.js

YUI.add("fizzbuzz", function(Y){

  // Private variable
  var myPrivateVar = "Fizz";

  // Export as public variable
  Y.fizz = myPrivateVar + " buzz"

}</code></pre>
    </div>
    
    
    <div class="slide">
        <h2>Loader</h2>
        
        <!-- 
        
        -->
        
        <p>YUI Loader Implementation</p>
        <pre><code class="prettyprint">&lt;!DOCTYPE html>
&lt;html>
  &lt;script src="http://yuim.in/">&lt;/script>
  &lt;script>
    YUI().use('fizzbuzz', function(Y) { 
      console.log(Y.fizz) // "Fizz buzz"
    });
  &lt;/script>
&lt;/html></code></pre>  
  <!-- -->
    </div>
    
    
    <div class="slide">
        <h2>Loader</h2>
        
        <!-- 
        
        -->
        
        <p>YUI Loader Implementation</p>
        <pre><code class="prettyprint">&lt;!DOCTYPE html>
&lt;html>
  &lt;script src='http://yuim.in/'> &lt;/script>
  &lt;script>
    YUI({
      modules:{
        fizzbuzz:{ fullpath: 'path/to/fizzbuzz.js' }
      }
    }).use('fizzbuzz', function(Y) { 
      console.log(Y.fizz) // "Fizz buzz"
    });
  &lt;/script>
&lt;/html></code></pre>  
  <!-- -->
    </div>
    
    
    <div class="slide">
        <h2>Loader</h2>
        
        <!-- 
        
        -->
        
        <pre><code class="prettyprint">// Example @ http://jsfiddle.net/derek/sfcsE/
YUI({
    modules: {
        'jquery': {
            fullpath: 'jquery.min.js',
            condition: 'before'
        },
        'jCarousel': {
            fullpath: 'jquery.jcarousel.min.js',
            requires: ['jquery', 'jCarouselCSS']
        },
        'jCarouselCSS': {
            fullpath: 'skin.css',
            requires: ['jCarouselCSS'],
            type: 'css'
        }
    }
}).use('jCarousel', function(Y) { ... });
        </code></pre>
        
        <!-- -->
    </div>

    
    <div class="slide">
        <h2>Loader</h2>
        
        <!-- 
        
        -->
        
        <iframe style="width: 100%; height: 500px" src="http://jsfiddle.net/derek/sfcsE/embedded/"></iframe>
    </div>

    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2><span>Combo-loading</span></h2>
        
        <!-- 
        
        -->
        
        <div><img src="http://www.seriouseats.com/images/20081210-yoshi-pica-bento.jpg" height="500"></div>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Combo-loading</h2>
        
        <!-- 
        
        -->
        
        <p>Addresses the problem of one-module-per-HTTP-request.</p>
        <div class="hide-previous"> 
            <p>Instead of:</p>
            <pre><code>GET moduleA.js
GET moduleB.js
GET moduleC.js

= 3 HTTP requests</code></pre>
<!-- -->
        </div>
        
        <!--
        Option A: 
        Manually cat the files together
        manually resolve your own dependencies
        retest
        
        or
        -->
        <div class="slide">
            <p>You get:</p>
            <pre><code>GET moduleA.js&amp;moduleB.js&amp;moduleC.js
            
= 1 HTTP request</code></pre></div>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Combo-loading</h2>
        <h1>"What about large URLs?"</h1>
        
        <!-- 
        
        -->
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h1>Modules + Loader + Combo service</h1>
        
        <!-- 
        
        -->
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Environment agnostic</h2>
        
        <!-- 
        
        -->
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h1>Why #3: <span class="slide">Open</span></h1>
        
        <!--
            Open Source
            Open Web
            Open CDN
            Open Hours
            Open Development
            Open Communication
            Open Documentation
        -->
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Open</h2>
        
        <!-- 
        
        -->
        
        <ul>
            <li class="slide">Open Source</li>
            <li class="slide">Open Web</li>
            <li class="slide">Open CDN</li>
            <li class="slide">Open Hours</li>
            <li class="slide">Open Development</li>
            <li class="slide">Open Communication</li>
            <li class="slide">Open Documentation</li>
        </ul>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Evolution</h2>
        
        <!-- 
        
        -->
        
        <div class="slide">
            <img src="http://images.nationalgeographic.com/wpf/media-live/photos/000/006/cache/platypus_662_600x450.jpg" height="500">
        </div>
        <!--
            I just mentioned that YUI was a suite of tools that naturally evolved.  So let's explore this concept for a bit.
            There's a very unique member of the animal kingdom, the platypus.
            
            The platypus
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>The Amazing Platypus</h2>
        
        <!-- 
        
        -->
        
        <ul>
            <li>Mammal > Monotreme > Platypoda</li>
            <li>Branched 220 million years ago</li>
        </ul>
        <div>
            <p class="slide">Why is it so unique?</p>
            <ul>
                <li class="slide">Duck-like bill</li>
                <li class="slide">Beaver-like tail</li>
                <li class="slide">Lays eggs</li>
                <li class="slide">Webbed feet</li>
                <li class="slide">Venomous</li>
                <li class="slide">Hunts blind</li>
                <li class="slide">10 sex chromosones</li>
            </ul>
        </div>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>The Amazing Platypus</h2>
        <!-- 
            The reason I'm here giving you a biology lesson is because YUI, much like the platypus, has developed many unique characteristics 
            over the years as a result of the unique environment that it has evolved in.
            
            Many of the tools of the platypus can be seen elsewhere in the animal kingdom on a variety of other animals, but you only
            get one, maybe two per species, whereas the platypus is an entire package of usefulness. The amazing thing is the platypus evolved all of these
            on its own.  
            
            The bill can be seen on birds, which is good for digging
            The tail can be seen on beavers, which is good for swimming
            It lays eggs, much like a reptile
            It has webbed feet, like aquatic birds
            It is venomous like many insects and snakes
            It hunts blind and deaf, using bat-like sonar 
            
            It lives & sleeps on land, but hunts mostly in rivers
        -->
        <img src="assets/platypus02.jpg" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Similarities?</h2>
        
        <!-- 
        
        -->
        
        <p>YUI and the Platypus are similar because they both evolved in unique environments and adapted.</p>
        <p>YUI characteristics can be found on many other JS libraries, but few match the diversity in one package.</p>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h1>Conclusion</h1>
        
        <!-- 
            We use YUI because it is the most versatile, extensible JavaScript library available.
        -->
    </div>
    
    <!-- 
    <div class="slide">
        <h2>YUI, more than DOM &amp; Ajax</h2>
        <p><strong>Rebecca Murphey</strong> - <a href="http://blog.rebeccamurphey.com/on-jquery-large-applications">On jQuery &amp; Large Applications</a></p>
        <blockquote style="font-style:italic; margin:left:5%;">
            "We have to make clear that, in fact, jQuery is but a hammer. 
            When it comes to building these intensively client-side applications, we’re talking about building skyscrapers, for god’s sake. 
            The problems solved by a hammer are the least of our concerns."
        </blockquote>
    </div>
    -->
    
    
    <!-- -------- -->
    
    
    <div class="slide templateB">
        <h2>Thanks!</h2>
        
        <!-- 
        
        -->
        
        <div>Slides @ <a href="http://derek.github.com/">http://derek.github.com</a></div>
    </div>
    
    
    <div class="slide templateB">
        <h1>Questions?</h1>
    </div>
    
    
    
    
    
    
    
    
    
    
    
    
    <!-- ------------------------------ -->
    <div class="slide" id="how">
        <h2>How Does It Work?</h2>
        <p>Upstage is a slideshow system built on <a href="http://yuilibrary.com/">YUI 3</a>.</p>
        <ol>
            <li>
                <h3>Create Slides</h3>
                <p>Slides are plain old HTML.</p>
            </li>
            <li>
                <h3>Tweak Styles</h3>
                <p>Upstage can be used with deck.js themes.</p>
            </li>
            <li>
                <h3>Extend and Enjoy</h3>
                <p>Built on YUI's rock-solid Widget architecture.</p>
            </li>
        </ol>
    </div>
    
    
    <div class="slide" id="getting-started">
        <h2>Getting Started</h2>
        <ol>
            <li>Get the <a href="https://github.com/reid/upstage/tree/widget">Upstage widget branch</a>.</li>
            <li>Copy <code>index.html</code> and the <code>build</code> directory to another directory.</li>
            <li>Start writing!</li>
        </ol>
    </div>
    
    
    <div class="slide" id="sample-code">
        <h2>Sample Code?</h2>
        <p>Upstage even can show off your code!</p>
        <pre><code>function Conference() {
    this.attendees = "you";
}

Conference.prototype.isAwesome = function() {
    if (this.attendees.indexOf("me") === -1) {
        throw new Error("Without me, it's just Aweso.");
    }
    return true;
};

var yuiconf = new Conference();
if (yuiconf.isAwesome()) deck.fire("warp", 1);</code></pre>
    </div>
    
    
    <div class="slide" id="architecture">
        <h2>Architecture</h2>
        <p>The Upstage core provides the architecture for the presentation. Make it useful by plugging in some of these:</p>
        
        <ul>
            <li class="slide" id="architecture-keyboard">
                <strong>UpstageKeyboard</strong>: Keyboard navigation.
            </li>

            <li class="slide" id="architecture-gesture">
                <strong>UpstageGesture</strong>: Gesture navigation.
            </li>
            
            <li class="slide" id="architecture-blanker">
                <strong>UpstageBlanker</strong>: Simple screen blanking.
            </li>

            <li class="slide" id="architecture-permalink">
                <strong>UpstagePermalink</strong>: Provides permalinks to slides that are unique per-slide.
            </li>
        </ul>
    </div>
<!-- .presentation -->
</div>

<script src="file:///Users/drg/Code/yui/yui3/build/yui/yui-min.js"></script>
<script>
    if (!window.YUI) {
        // Retry with a local URL.
        document.write('<script src="yui3/build/yui/yui.js"><\/script>');
        // Don't autodetect the base path (the CDN path didn't work).
        document.write('<script>YUI.config.base = "yui3/build/";<\/script>');
    }
</script>
<script>
    YUI({
        modules: {
            "upstage-blank": {
                fullpath: "build/upstage-blank-min.js",
                requires: ["upstage-slideshow", "plugin"]
            },
            "upstage-controls": {
                fullpath: "build/upstage-controls-min.js",
                requires: ["upstage-slideshow", "widget", "transition", "node"]
            },
            /*"upstage-gesture": {
                fullpath: "build/upstage-gesture-min.js",
                requires: ["upstage-slideshow", "plugin", "event-move"]
            },*/
            "upstage-keyboard": {
                fullpath: "build/upstage-keyboard-min.js",
                requires: ["upstage-slideshow", "plugin", "event-key"]
            },
            "upstage-permalink": {
                fullpath: "build/upstage-permalink-min.js",
                requires: ["upstage-slideshow", "node", "plugin", "history", "selection"]
            },
            "upstage-slideshow": {
                fullpath: "build/upstage-slideshow-min.js",
                requires: ["oop", "node", "widget"]
            },
            'gallery-prettify': {
                fullpath: 'build/gallery-prettify/gallery-prettify.js',
                requires: ['gallery-prettifyCSS']
            },
            'gallery-prettifyCSS': {
                fullpath: 'build/gallery-prettify/gallery-prettify-skin.css',
                type: "css"
            }
            // For controls plugin-widget:
            // It should be a sub-Widget, but pluggable into deck.
            // Also, it should create the prev/next links
            // unlike deck.js which puts dummy links in markup.
        },
        debug: true,
        filter: "min"
    }).use(
        "upstage-slideshow",
        "upstage-keyboard",
        "upstage-permalink",
        "upstage-gesture",
        "upstage-blank",
        "gallery-prettify",
        function (Y) {
            // Upstage is a YUI widget.
            var deck = new Y.Upstage({
                srcNode: "#bd" // Where to find .slide elements.
            });
            
            // Make the code pretty
            Y.prettyPrint();
            
            // Upstage does not do much without plugins.
            // They are all optional. Use only what you need.
            deck.plug([
                Y.Plugin.UpstageKeyboard,
                Y.Plugin.UpstageBlank,
                Y.Plugin.UpstageGesture,
                Y.Plugin.UpstagePermalink
            ]);

            deck.render();
        }
    );
</script>

</body>

</html>


<!--



<div class="slide">
    <h2>Sandboxes</h2>
    <img src="http://wtfcontent.com/img/130207816278.jpg" height="500">
    
        Sandboxes are a broadly used term in JavaScript.  Sometimes they are in reference to 
        Sandboxes sound scary at first, but they're really very, very simple.  The idea is that you control what instance of YUI you use,
        regardless of how deeply nested you are.  This is especially important when you are working on large teams where it becomes 
        
</div>


<div class="slide">
    <h2>Sandboxes</h2>

    <pre><code class="prettyprint">YUI().use('yql', function(Y){

Y.log(typeof Y.YQL); // function

Y.use(function(X){
    Y.log(typeof X.YQL); // function
});

YUI().use(function(Y){
    Y.log(typeof Y.YQL); // undefined
});

});</code></pre>

</div>


<div class="slide">
    <h2>But I don't like sandboxes</h2>

    <pre><code class="prettyprint">// Fine, export as a global
        
var Y = YUI().use('yql');</code></pre>

</div>
-->
