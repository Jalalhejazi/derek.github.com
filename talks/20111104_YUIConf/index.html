<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    
    <title>Why YUI | JSConf 2011</title>

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=1024, user-scalable=no">

    <link rel="stylesheet" href="theme/reset.css">
    <link rel="stylesheet" href="build/upstage-deck-core-min.css">
    <link rel="stylesheet" href="theme/transition.css">
    <link rel="stylesheet" href="theme/yuiconf2011.css">
    
    <style>
    .slide h1{
        font-size:2.3em;
    }
    
    .templateB{
        position: relative;
    }
    
    .templateB h3{
        text-align: center;
        font-size: 3.0em;
        top: 20%;
    }
        
    .templateB .slide p {
        font-size: 1.8em;
        margin-left: 5%;
    }
    
    .asd {
        display:none;
    }
    
    .slide a {
        text-decoration:underline;
    }
    
    .slide.deck-previous>.hide-previous {
        display:none;
    }
    </style>
</head>

<body>

<div id="bd" class="deck-container">

    <div class="slide title">
        <h1>Why YUI?</h1>
        <p>Derek Gathright, Yahoo! Inc.</p>
    </div>


    <!-- -------- -->


    <div class="slide">
        <h2>Who is this guy?</h2>
        
        <!--
        
            Hi, I'm Derek Gathright.
            I'm a senior software engineer here at Yahoo where I work on YUI full-time.
            Prior to joining the YUI team, I worked on other projects at Yahoo within Media and Entertainment as a front-end engineer.
            I'm a huge advocate of open-source and I love JavaScript
            You can follow me both on Twitter & Github as @derek
            
        -->
        
        <img style="float:right;" src="assets/derek.jpg" height="350">
        <ul>
            <li>Derek Gathright</li>
            <li>Software engineer, Yahoo!
                <ul>
                    <li>YUI team</li>
                    <li>Yahoo! Media</li>
                    <li>... various startups</li>
                </ul>
            </li>
            <li>&lt;3 open-source</li>
            <li>&lt;3 JavaScript</li>
            <li>Twitter &amp; Github as @derek</li>
        </ul>
    </div>


    <!-- -------- -->


    <div class="slide templateB">
        <h1>What is this talk about?</h1>
        <!--
        
            So what is this talk about?  That's a good question.  
            It's a bit more philosophical than most of the talks you'll see here at YUIConf.
            I originally wanted to give a talk on porting an application from another library to YUI, but I felt that was missing 
            the story of why you would want to do that in the first place.  
            So as I talked to other developers on the YUI team and within the community about their favorite parts of the library, 
            and why it is they used YUI, I began to see some patterns emerge.  
            So this talk is a reflection of those conversations. 
            
            In short, it's a talk about what makes YUI the most uniquely ideal toolkit to build high-scale, maintainable Web applications.
            
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Why YUI?</h2>
        <h1>#1: <span class="slide">Architecture</span></h1>
        <!--
        
            The first 'why' we're going to look at is... architecture.
            When I say "architecture", most people think of this...
            
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            The Sydney Opera House is one of the most recognizable structures on the planet.
            It's expressionist design is beautiful, elegant, and iconic.
            Some have even called it a masterpiece.
            
            While most people imagine building when they think of "architecture", we're nerds, 
            so we think of this...
            
            [click]
        -->
        
        <img src="assets/opera.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            Not quite as pretty is it?  Well, there is elegance here, it's just not as apparent in this component diagram.
            
            Let's view it in it's physical form
            
            [click]
        -->
        
        <img src="assets/iss_comp.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <!--
            The International Space Station wasn't designed with beauty in mind, but it's undeniably there.
            
            When we talk about architecture in the sense of software, 
            we're talking about something very similar to the design of something like the space station.
            
            Well architected software is composed of reusable and interchangeable components in a way that 
            promotes 
            reliability, 
            maintainability, 
            compatibility, 
            and extensibility.
                
            So let's take a look at some of those "ilities"
            
            [click]
        -->
        
        <img src="assets/iss.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h1>Modularity</h1>
        
        <!--
        
            Modules are a concept used across many engineering disciplines.  
            In a space station sense, they refer to the 32 separately constructed components that compose the IIS.
            
            In a software sense, they similarly refer to bits of focused, interchangeable components 
            that you can use to construct whatever system you are tasked with.
            
            You'll find native module support in many programming languages.  Ruby, Java, Python.  
            But unfortunately not in JavaScript. Why? Well, it's pretty obvious.  
            JavaScript was developed over the course of a few weeks.  
            I don't think that was a consideration at the time.
            Well, to everyone's surprise though, JS has thrived, and the need for them is here, 
            so it's been left up to developers to design their own module patterns.
            
            [click]
            
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>JS Modules</h2>

        <!-- 
        
            Here is just one example of a JavaScript module, as proposed on the yuiblog 4 years ago.
            You start with assigning an anonymous function to whatever you want to name your module.  
            Inside this module, you can create whatever private variables you'd like, 
            and you return an object containing things you would like to publicly expose.
            Finally, you execute and return your anonymous function.
            
            There are a number of strengths and weaknesses to this design, 
            and over time, the YUI team finally settled on similar, but slightly different design for YUI3.
            
            [click]
            
        -->
        
        <pre class="slide"><code class="prettyprint">// yuiblog.com/blog/2007/06/12/module-pattern/
myLibrary.fizzbuzz = (function () {

  var somePrivateVar = "Fizz";
  
  return {
    fizzbuzz: myPrivateVar + " Buzz"
  };
  
})();</code></pre>

    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>YUI Modules</h2>

        <!-- 
        
            This module does the exact same thing the previous example did, the implementation 
            is slightly different though.

            You have the same capabilities for private members, and whatever you'd like to expose to 
            the public is attached to the Y object.

            Modules are a fundamental building block for everything you do in YUI.  
            Between the Core library and the YUI Gallery, 
            you'll see over 600 modules that you can use inside of your application 
            to do everything from 
            DOM manipulation,
            animation, 
            object-oriented helpers, 
            and many more.

            It is not intended that you use all of them at the same time, 
            but rather to pick and chose only the ones you want.
            
            
            [click]
            
        -->
        
        <pre><code class="prettyprint">// fizzbuzz.js

YUI.add("fizzbuzz", function(Y){

  // Private variable
  var myPrivateVar = "Fizz";

  // Export as public variable
  Y.fizzbuzz = myPrivateVar + " buzz";

});</code></pre>

    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>JS Modules</h2>
        
        <!-- 
            YUI is one of the few popular JavaScript libraries that uses this modular architecture, 
            but we're seeing greater adoption from other libraries.  
            We're even starting to see standards emerge, such as AMD and CommonJS.
            
            Dojo is has recently adopted the AMD pattern, and Node.js has popularized CommonJS Modules/1.1.
            
            YUI is really happy with YUI Modules so far, but that's not to say we haven't begun 
            exploring additional support for other formats.
            If you compare all the specs, YUI is kind of a mixture between the two.
            If you are curious about the work being done here, 
            check out the YUI forum for discussion about this topic.
            We're very interested in hearing your feedback.
            
            [click]
            
            The eventual goal is native ECMAScript modules, which are coming, but they're still in the proposal phase.  
            When they've finally arrived, we still won't be able to use them in an environment 
            that needs to support legacy browsers because they won't be compatible with ES3, 
            so I'm not sure how much adoption they'll actually have inside of browsers.  We'll see.
            
            This makes it even more important that we as a JavaScript community come up with a 
            standard that it both backwards, and forwards compatible,
            and one that also runs equally as well server-side and within browsers.
            
            [click]
        -->
        
        <p>Emerging standards</p>
        <ul>
            <li>AMD (Asynchronous Module Definition)</li>
            <li>CommonJS Modules/1.1</li>
            <li>CommonJS Modules/2.0 (draft)</li>
            <li>... and more</li>
        </ul>
        <p class="slide">Eventual goal: <a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">ECMAScript Modules</a>.  Still just a proposal, and incompatible with ES3. :(</p>
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <!--
            So we've talked about briefly about modular design in JS, but what do you get out of it?  
            
            The #1 thing....
            
            [click]
        -->
        <h1>What do you gain from modularity?</h1>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Extensibility</h2>
        <!--
            Extensibility
            
            This is the idea that a your code is designed with future growth in mind.  
            Even, to be able to grow in ways it was never intended.
            When working within a library, it's extremely important that you consider all types of edge-cases, 
            and make it possible for developers who are going to be using your code to 
            replace or extend functionality you provide them with their own.
            
            When you think about extensibility with software, a good comparison might be...
            
            [click]
            
            Lightning McQueen.
        -->
        
        <img src="assets/lego.jpg" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <!--
        
            This specific toy was designed to be only one thing, 
            look exactly like Lightning McQueen did in the original Cars movie.  
            
            I'd say they did a pretty good job.  
            
            But the problem is what happens in the next sequel when Lightning 
            is getting older and needs rocket boosters to get around the track.  
            
            Or the sequel after that when he has a midlife crisis and wants to be a convertible.
        
            [click]
        
        -->
        
        <img src="assets/lmq01.jpg" height="500">
        <!-- source: http://www.treklens.com/gallery/photo149022.htm -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            Something like this might be more appropriate.
            
            With this design, you can quickly remove the spoiler and replace 
            with the rocket booster plugin you bought.
            
            Then you can just remove the top and turn it into a convertible.
            
            In the previous design, you are stuck with exactly what you bought and 
            have to buy a new toy every time a movie comes out.
            
            But I'm sure that's what Disney wants. :)
            
            [click]
        -->
        
        <img src="assets/lmq02.jpg" height="500">
        <!-- source: http://www.pixartalk.com/2011/08/lego-lightning-mcqueen/ -->
        
    </div>
    
    <!-- Time: 10 min -->
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!--
            In application development, one constant is change.  
            
            This is especially true on the Web where new ideas, 
            technologies, patterns, techniques, libraries, and standards, are all evolving at an accelerated pace.
            
            Years ago, when I was working on a startup that was using jQuery, 
            a new feature we needed was a rich text editor.
            So I did what most jquery users do, search "jquery rich text editor plugin."  
            I came across lots of blog posts
            "top 12 jQuery editor plugins", 
            "10 jquery-based rich text editors to blow your mind"  
            
            This stuff reads like a Cosmo magazine.
            
            So I click through each one, play around with the demo, 
            figure out which one most meets my spec, paste it in, glue it together, viola. 
            Done.
            
            2 weeks later, "Oh, we need the ability to upload and add pictures within the editor."
            Now my first thought is "Gee, that would have been great to know a few weeks ago."  
            But that still doesn't change the problem I have.  
            I now have a feature that I need to integrate with an editor that it was never designed to support.
            Sure I could crack open the plugin and start hacking away until I got it working, 
            or just gave up and try another editor.
            
            The point of this is...
            
            [click]
        -->
        
        <img src="assets/change.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        
        <!-- 
            Don't hack.  Extend.
            
            Most of our business cards say something similar to "front end engineer", "web engineer".  
            Well, where do you think the "engineer" part comes from?
            
            Our jobs are not to throw together a pile of code, 
            deliver it to the next person who will hack in some modifications, 
            and then deliver that so some other poor sap that is in charge of maintaining it.
            
            You just end up with unmaintainable junk that is thrown away when it no longer fits a spec, 
            and the process is destined to repeat itself over again.
            
            Every component within YUI is developed with extensibility in mind.
            
            Some of the teams that use YUI within Yahoo never use the vanilla versions of the components we have.  
            They endlessly modify and extend them to suit their exact needs.
            
            **pause***
            
            When you talk about things like components, modules, extensibility, 
            one of the things you hear is "Ohhh... that sounds very enterprisey"
            
            So let's talk about this myth for a second
            
            [click]
        -->
        
        <h1>Don't hack <br /> <br /> Extend</h1>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide" >
        <h2></h2>
        
        <!-- 
            I go to a lot of meetups, pub nights, and talk with a lot of people about YUI.
            This isn't something I hear all the time, 
            but it's something I hear enough. I'm sure the rest of you have as well.
            
            What do you even mean when you say enterprisey?
            
            Are you talking about this? ...
            
            [click]
        -->
        
        <h1>Myth: "YUI is too enterprisey"</h1>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Enterprisey?</h2>
        
        <!--
            If so, Awesome!
            I could probably do a whole talk about comparing YUI to the Starship Enterprise.
            But I have a feeling they aren't talking about it in that sense.
            
            [click]
        -->
        
        <img src="assets/change.jpg" height="500">
        
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Enterprisey?</h2>
        
        <!--
            Instead, it's more something like this convoluted mystery machine 
            that appears foreign to people.  It's this scary land of modules, components, and widgets.
            
            YUI is actually extremely simple if you know how to read a little bit of documentation at yuilibrary.com.
            Play with the examples, hack around with the code, watch videos on YUITheater.com
            
            YUI is just a suite of tools that naturally evolved to suit the needs of Yahoo, the team, and our community.
            You can use as many, or as few of the tools as you like.  Again, modular, extensible design.
            
            So let's dive into the tools a little more.  This brings me to
            
            [click]
        -->
        
        <img src="assets/complexity.gif" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Why YUI?</h2>
        <h1>#2: <span class="slide">Infrastructure</span></h1>
        <!-- 
            Why YUI #2.
            
            [click]
            
            Infrastructure.
            
            [click]
        
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Toolkit</h2>
        
        <!--
            YUI is called a library, but I personally view it more as a toolkit.  
            That's not saying the "library" term is incorrect.  
            Library, toolkit, and sometimes framework are often used interchangeably, 
            so I don't want to get lost in semantics.  
            
            The reason I say 'toolkit' most accurately describes YUI is because it allows 
            you to pick & choose what it is you want, and nothing more.
            
            [click]
        -->
        
        <img src="assets/toolbox.jpg" height="500">
        
    </div>
    
    <div class="slide">
        <h2>Tools</h2>

        <!--
            If you just want a DOM selector/editor, ok, YUI use "node".
            
            Canvas/SVG/VML graphics, then use graphics
            
            Want a calendar widget, use calendar
            
            YQL client, use YQL
            
            So these are all pretty typical modules with what you'll find in YUI.  
            There are certainly some more unique ones that you can use though. 
            
            [click]
        -->
        
        <pre><code>// DOM
YUI().use('node', function (Y) { ... });

// Canvas/SVG/VML graphics
YUI().use('graphics', function (Y) { ... });

// Calendar widget
YUI().use('calendar', function (Y) { ... });

// YQL client
YUI().use('yql', function (Y) { ... });</code></pre>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>YUI Loader</h2>
        
        <!--
            One of those, is Loader.
            
            Some of you might recognize this picture.  
            It's from the movie Aliens, of Ripley in her power-loader about to open a 
            can of whoop-ass on the queen alien.
            
            Unfortunately, as web developers, we don't have any aliens we get to fight on a daily basis.
            
            But there are some things out there that are just a royal pain in the ass to do perfectly, 
            and one of those is script loading.
            
            [click]
        -->
        
        <img src="assets/loader.jpg" height="500">
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Modular loading</h2>

        <!-- 
        
            Let's take a look at a pretty typical page that is using a modular, 
            or a psuedo-modular method of organizing code.
            
            You have the core library which you need to load in first, 
            then you start including your modules one by one.
            
            Depending on what your browser is doing, you might be loading 1, or all of them at the same time.  
            They're all executed in that specific order though, one by one.
            
            So, there are a number of issues here when you consider performance.
            
            First of all, you are blocking rendering because you stuffed all your JavaScript into the head element.
            Next, you have a very fragile load order.  
            What if you include your coreLibrary.js last? 
            What if moduleB requires moduleA?
            Do you load all 27 modules you have on every page? 
            Load them selectively? 
            How do you handle dependency resolution? 
            Dependency calculation?
            What about CSS dependencies for UI widgets?
            
            These were just some of the issues that immediately popped in my head.  
            I'm sure there are plenty more.
            
            So as you can guess, these are all issues Loader fixes.
            
            [click]
            
        -->
        
        <p>So we organized into modules, great!</p>
        <pre><code class="prettyprint">&lt;head>
  &lt;script src='/js/coreLibrary.js'> &lt;/script>
  &lt;script src='/js/moduleA.js'> &lt;/script>
  &lt;script src='/js/moduleB.js'> &lt;/script>
  &lt;script src='/js/moduleC.js'> &lt;/script>
  &lt;script src='/js/moduleD.js'> &lt;/script>
&lt;/head></code></pre>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Goal of a module loader?</h2>
        <!-- 
            The goal of a module loader is
            
            [click]
            
            to optimize and simply the process of loading in modules.
            
            It addresses the issue of blocking by async loading
            
            Addresses dependencies with automatic dependency resolution
            
            On-demand modules loading anywhere within your application
            
            Supports CSS
            
            ... and more
            
            [click]
        -->
        <p>To optimize and simplify the process of loading modules.</p>
        <div class="slide">
            <p>How?</p>
            <ul>
                <li>Async loading</li>
                <li>Automatic dependency resolution</li>
                <li>On-demand module loading</li>
                <li>CSS support</li>
                <li>... and more</li>
            </ul>
        </div>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>YUI Loader</h2>
        
        <!-- 
        
            So let's go back to our YUI Module example we used earlier.
            
            If you want to use Loader to include this module instead of using a script tag, here's how you do it.
            
            [click]
            
        -->
        
        <p>YUI Modules example (again)</p>
        <pre><code class="prettyprint">// fizzbuzz.js

YUI.add("fizzbuzz", function(Y){

  // Private variable
  var myPrivateVar = "Fizz";

  // Export as public variable
  Y.fizz = myPrivateVar + " buzz"

}</code></pre>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>YUI Loader</h2>
        
        <!-- 
        
            We're missing one part though.  Loader doesn't know where fizzbuzz.js is.  
        
            There are a few ways you can tell it the path, 
            but the easiest way is just to use a modules configuration object.
            
            So let's include that bit
            
            [click]
        -->
        
        <pre><code class="prettyprint">&lt;!DOCTYPE html>
&lt;html>
  &lt;script src='http://yuim.in/'>&lt;/script>
  &lt;script>
    YUI().use('fizzbuzz', function(Y) { 
      console.log(Y.fizz) // "Fizz buzz"
    });
  &lt;/script>
&lt;/html></code></pre>  
  <!-- -->
    </div>
    
    
    <div class="slide">
        <h2>YUI Loader</h2>
        
        <!--
            Here we added in a loader configuration object, 
            which tells us where exactly it will be able to find the module fizzbuzz.
            
            Loader isn't only for loading YUI modules.  
            
            As I mentioned earlier, you can include CSS, 
            and you can even include arbitrary JavaScript.
            
            [click]
        -->
        
        <pre><code class="prettyprint">&lt;!DOCTYPE html>
&lt;html>
  &lt;script src='http://yuim.in/'>&lt;/script>
  &lt;script>
    YUI({
      modules:{
        fizzbuzz:{ fullpath: 'path/to/fizzbuzz.js' }
      }
    }).use('fizzbuzz', function(Y) { 
      console.log(Y.fizz) // "Fizz buzz"
    });
  &lt;/script>
&lt;/html></code></pre>
    </div>
    
    
    <div class="slide">
        <h2>YUI Loader</h2>
        
        <!-- 
            [explain]
        -->
        
        <pre><code class="prettyprint">// Example @ http://jsfiddle.net/derek/sfcsE/
YUI({
    modules: {
        'jquery': {
            fullpath: 'jquery.min.js',
            condition: 'before' },
        'jCarousel': {
            fullpath: 'jquery.jcarousel.min.js',
            requires: ['jquery', 'jCarouselCSS'] },
        'jCarouselCSS': {
            fullpath: 'skin.css',
            requires: ['jCarouselCSS'],
            type: 'css' }
    }
}).use('jCarousel', function(Y) { ... });
        </code></pre>
        
    </div>

    
    <div class="slide">
        
        <!-- 
            [demo]
        -->
        
        <iframe style="width: 100%; height: 600px;" src="http://jsfiddle.net/derek/sfcsE/embedded/"></iframe>
    </div>

    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2></h2>
        <!-- 
            So we've looked at Loader, which is a tool you can use to asynchronously request each YUI module.  
            
            One of the problems you may run into if you have 50 modules to load on your page, 
            you are doing 50 HTTP requests. 
            
            So as you can imagine, YUI has a solution for that.
            
            [click]
        -->
    </div>
    
    
    <!-- -------- -->
    
    <div class="slide">
        
        <h2>Combo-loading</h2>
        <!--
            For those of you that don't recognize this, it's a bento box.
            You'll find these in Japan sold at convenience stores, train stations, and bento shops.
            
            It's basically a meal to go.
            A packaged mixture of various types of food for a quick, convenient meal, and not much more.
            
            That pretty accurately describes what YUI's combo-loading service does. 
            The idea is to combine everything you need into a single, optimized HTTP request.
            
            [click]
        -->
        <div><img src="assets/bento.jpg" height="500"></div>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Combo-loading</h2>
        
        <!--
            [explain]
            
            [click]
        -->
        
        <p>Addresses the problem of one-module-per-HTTP-request.</p>
        <div class="hide-previous"> 
            <p>Instead of:</p>
            <pre><code>GET moduleA.js
GET moduleB.js
GET moduleC.js

= 3 HTTP requests</code></pre>
<!-- -->
        </div>
    </div>
        
    <div class="slide">
        <h2>Combo-loading</h2>
        <!--
            You get all your modules, concatenated together.
        
            [click]
        -->
        <p>You get:</p>
        <pre><code>GET moduleA.js&amp;moduleB.js&amp;moduleC.js
        
= 1 HTTP request</code></pre></div>

    <div class="slide">
        <h2>Combo-loading</h2>
        <!--
            What about long URLs?
        
            [click]
        -->
        <p>What about long URLs?</p>
        <pre><code>GET moduleA.js&amp;moduleB.js&amp;moduleC.js
GET moduleD.js&amp;moduleE.js&amp;moduleF.js
        
= 2 HTTP requests</code></pre>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <!-- 
            When you take the idea of CDN hosted combo-loading, then add in Modules, and top it off with Loader,
            that's when you get something truly unique among JavaScript libraries.
            
            This is a killer feature.
            As Dav Glass would say, that's "Huge".
        -->
        <h1><span class="slide">Combo-loading</span> <br /> <span class="slide">+ Modules</span> <br /> <span class="slide">+ Loader</span> <br /> <span class="slide">= That's huge!</span</h1>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Additional Tools</h2>
        
        <!-- 
            I'd love to stay up here and continue talking about all the other great tools within YUI, 
            but there's just not enough time.
        -->
        
        <ul>
            <li>Y.Base, Events, Plugins, Extensions, Widgets, ...</li>
            <li>YUI Compressor</li>
            <li>YUI Builder</li>
            <li>YUI Doc, Selleck</li>
            <li>CSS Reset, Grids</li>
            <li>Undocumented stuff hidden in Dav's 91 Github repositories</li>
            <li>... many more</li>
        </ul>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Why YUI?</h2>
        <h1>Why #3: <span class="slide">Open</span></h1>
        <!--
            This final reason is easily my favorite for why we use YUI.
            In my opinion, it's the reason the YUI project has been able to thrive, 
            and the reason we're all here today.
            
            And that is...
            
            [click]
            
            It's open.
            
            [click]
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h2>Open</h2>
        
        <!--
            
            Open isn't just what we do with our source code, it's the mentality of the entire project.
            
            Open Source
                The library is completely 100% open-source and hosted on Github where we're 
                now accepting pull-requests.
                We use a BSD license, one of the most permissive licenses available.
                You don't have to be a team member to contribute code to the YUI core.  
                Just sign a CLA and you are good to go.
            
            Open CDN
                We even have an open CDN, the YUI Gallery, which you can use to publish 
                whatever YUI modules you'd like.
                This is yet another feature that few, if any other, JavaScript libraries can offer.
            
            Open Hours
                We even have meetings in the open.  
                Open Hours is a 1-2 times per month hour-long meeting where we discuss with the community
                things we're working on, invite others to show off things they're doing, 
                and answer questions anyone has.
            
            Open Development
                Pretty much everything we work on is developed in the open.
                The few things that aren't are developed with the intent to eventually be open-source.
                Our entire ticketing system, roadmap, and assignments are all visible for anyone to see.
        
            Open Communication
                We spend all day in IRC, #yui on freenode.  
                We have an active forum that you can go to ask any questions you have.
                Most of us all tweet, you should follow yuilibrary and yuirelay.
        
            Open Documentation
                With the release of 3.4.0 and the new yuilibrary.com website, 
                all our documentation is now available for anyone to update, edit, and add examples.  
                You'll now find a /docs/ directory inside of each module where this lives.  
                It's using Selleck, a Node.js based documentation generation tool Ryan Grove developed.
                I'd consider JSRosettaStone.com as part of our documentation as well, check it out.
            
        -->
        
        <ul>
            <li class="slide">Open Source</li>
            <li class="slide">Open Web</li>
            <li class="slide">Open CDN</li>
            <li class="slide">Open Hours</li>
            <li class="slide">Open Development</li>
            <li class="slide">Open Communication</li>
            <li class="slide">Open Documentation</li>
        </ul>
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide">
        <h1>Conclusion</h1>
        
        <!-- 
            We use YUI because it is without a doubt, the most versatile, extensible JavaScript library available.
            And I want to emphasize JAVASCRIPT, because YUI isn't just a DOM manipulation library, 
            or a set or Ajax tools,
            or a server-side web application library,
            it is everything.
            
            Seriously, there's nothing you can't do in YUI, because it's just JavaScript.  
            
            The goal of YUI isn't to replace JavaScript, it's to embrace it.
            
            [click]
        -->
    </div>
    
    
    <!-- -------- -->
    
    
    <div class="slide templateB">
        <h2>Thanks!</h2>
        
        <!-- 
        
        -->
        
        <div>Slides @ <a href="http://derek.github.com/">http://derek.github.com</a></div>
    </div>
    
    
    <div class="slide templateB">
        <h1>Questions?</h1>
    </div>
    
    
<!-- .presentation -->
</div>

<script src="file:///Users/drg/Code/yui/yui3/build/yui/yui-min.js"></script>
<script>
    if (!window.YUI) {
        // Retry with a local URL.
        document.write('<script src="yui3/build/yui/yui.js"><\/script>');
        // Don't autodetect the base path (the CDN path didn't work).
        document.write('<script>YUI.config.base = "yui3/build/";<\/script>');
    }
</script>
<script>
    YUI({
        modules: {
            "upstage-blank": {
                fullpath: "build/upstage-blank-min.js",
                requires: ["upstage-slideshow", "plugin"]
            },
            "upstage-controls": {
                fullpath: "build/upstage-controls-min.js",
                requires: ["upstage-slideshow", "widget", "transition", "node"]
            },
            /*"upstage-gesture": {
                fullpath: "build/upstage-gesture-min.js",
                requires: ["upstage-slideshow", "plugin", "event-move"]
            },*/
            "upstage-keyboard": {
                fullpath: "build/upstage-keyboard-min.js",
                requires: ["upstage-slideshow", "plugin", "event-key"]
            },
            "upstage-permalink": {
                fullpath: "build/upstage-permalink-min.js",
                requires: ["upstage-slideshow", "node", "plugin", "history", "selection"]
            },
            "upstage-slideshow": {
                fullpath: "build/upstage-slideshow-min.js",
                requires: ["oop", "node", "widget"]
            },
            'gallery-prettify': {
                fullpath: 'build/gallery-prettify/gallery-prettify.js',
                requires: ['gallery-prettifyCSS']
            },
            'gallery-prettifyCSS': {
                fullpath: 'build/gallery-prettify/gallery-prettify-skin.css',
                type: "css"
            }
            // For controls plugin-widget:
            // It should be a sub-Widget, but pluggable into deck.
            // Also, it should create the prev/next links
            // unlike deck.js which puts dummy links in markup.
        },
        debug: true,
        filter: "min"
    }).use(
        "upstage-slideshow",
        "upstage-keyboard",
        "upstage-permalink",
        "upstage-gesture",
        "upstage-blank",
        "gallery-prettify",
        function (Y) {
            // Upstage is a YUI widget.
            var deck = new Y.Upstage({
                srcNode: "#bd" // Where to find .slide elements.
            });
            
            // Make the code pretty
            Y.prettyPrint();
            
            // Upstage does not do much without plugins.
            // They are all optional. Use only what you need.
            deck.plug([
                Y.Plugin.UpstageKeyboard,
                Y.Plugin.UpstageBlank,
                Y.Plugin.UpstageGesture,
                Y.Plugin.UpstagePermalink
            ]);

            deck.render();
        }
    );
</script>

</body>

</html>
















<!--



<div class="slide">
    <h2>Sandboxes</h2>
    <img src="http://wtfcontent.com/img/130207816278.jpg" height="500">

        Sandboxes are a broadly used term in JavaScript.  Sometimes they are in reference to 
        Sandboxes sound scary at first, but they're really very, very simple.  
        The idea is that you control what instance of YUI you use, regardless of how deeply nested you are.

</div>


<div class="slide">
    <h2>Sandboxes</h2>

    <pre><code class="prettyprint">YUI().use('yql', function(Y){

Y.log(typeof Y.YQL); // function

Y.use(function(X){
    Y.log(typeof X.YQL); // function
});

YUI().use(function(Y){
    Y.log(typeof Y.YQL); // undefined
});

});</code></pre>

</div>


<div class="slide">
    <h2>But I don't like sandboxes</h2>

    <pre><code class="prettyprint">// Fine, export as a global
        
var Y = YUI().use('yql');</code></pre>

</div>
-->
